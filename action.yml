name: "ZKsync Server Action (L1 + L2)"
description: "Starts anvil (L1) and zksync_os_server (L2) for L1-L2 testing"
author: "dutterbutter"
branding:
  icon: "server"
  color: "blue"

inputs:
  version:
    description: "Release tag (e.g. v0.8.2) or 'latest'"
    default: "latest"
  include_prerelease:
    description: "Allow pre-releases when version is 'latest'"
    default: "false"
  l1_port:
    description: "L1 (Anvil) RPC port"
    default: "8545"
  l2_port:
    description: "L2 (ZKsync OS) RPC port"
    default: "3050"
  linux_arch:
    description: "Linux arch (x86_64 or aarch64)"
    default: "x86_64"
  wait_seconds:
    description: "Seconds to wait for L2 readiness"
    default: "300"
  set_env:
    description: "If 'true', export ETH_RPC and ZKSYNC_RPC to GITHUB_ENV"
    default: "true"

outputs:
  l1_rpc_url:
    description: "Resolved L1 RPC URL"
    value: ${{ steps.vars.outputs.l1 }}
  l2_rpc_url:
    description: "Resolved L2 RPC URL"
    value: ${{ steps.vars.outputs.l2 }}
  resolved_version:
    description: "Resolved tag actually used (e.g. v0.8.2)"
    value: ${{ steps.resolve.outputs.tag }}

runs:
  using: "composite"
  steps:
    - id: vars
      shell: bash
      run: |
        echo "l1=http://127.0.0.1:${{ inputs.l1_port }}" >> "$GITHUB_OUTPUT"
        echo "l2=http://127.0.0.1:${{ inputs.l2_port }}" >> "$GITHUB_OUTPUT"

    # Resolve 'latest' via GitHub API (optionally including pre-releases)
    - id: resolve
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const owner = 'matter-labs';
          const repo  = 'zksync-os-server';

          const version = (process.env.VERSION || 'latest').trim();
          const includePre = (process.env.INCLUDE_PRE || 'false').toLowerCase() === 'true';

          let tag = version;

          async function latestStable() {
            const res = await github.rest.repos.getLatestRelease({ owner, repo });
            return res.data.tag_name;
          }

          async function latestIncludingPrerelease() {
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner, repo, per_page: 10,
            });
            const rel = releases.find(r => !r.draft); // first is newest
            if (!rel) throw new Error(`No releases found for ${owner}/${repo}`);
            return rel.tag_name;
          }

          try {
            if (version === 'latest') {
              tag = includePre ? await latestIncludingPrerelease() : await latestStable();
            }
            core.info(`Resolved zksync-os-server tag: ${tag}`);
            core.setOutput('tag', tag);
            core.setOutput('base', `https://github.com/${owner}/${repo}/releases/download/${tag}`);
          } catch (err) {
            core.setFailed(`Failed to resolve release tag for ${owner}/${repo}: ${err.message || err}`);
          }

    - name: Download release assets
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p .zks && cd .zks
        base="${{ steps.resolve.outputs.base }}"
        tag="${{ steps.resolve.outputs.tag }}"
        arch="${{ inputs.linux_arch }}"
        tgz="zksync-os-server-${tag}-${arch}-unknown-linux-gnu.tar.gz"

        echo "Resolved tag: $tag"
        echo "Downloading assets from: $base"
        curl -sSL -O "$base/$tgz"
        curl -sSL -O "$base/zkos-l1-state.json"
        curl -sSL -O "$base/genesis.json"
        mkdir -p genesis
        mv -f genesis.json genesis/genesis.json

        # Show archive contents for debugging
        echo "Listing archive contents:"
        tar -tzf "$tgz" | sed -n '1,200p'

        # Extract
        tar -xzf "$tgz"

        # Locate the server binary (handle both name + subfolder cases)
        BIN_CANDIDATE=""
        for name in zksync_os_bin zksync-os-server; do
          # exact match in cwd
          if [[ -f "$name" ]]; then BIN_CANDIDATE="$name"; break; fi
          # within one subdir (common packaging)
          found="$(find . -maxdepth 2 -type f -name "$name" | head -n1 || true)"
          if [[ -n "$found" ]]; then BIN_CANDIDATE="$found"; break; fi
        done

        if [[ -z "$BIN_CANDIDATE" ]]; then
          echo "ERROR: Could not find server binary in archive."
          echo "Top-level tree:"
          ls -la
          echo "Recursive tree (depth 2):"
          find . -maxdepth 2 -type f -print
          exit 1
        fi

        echo "Found server binary at: $BIN_CANDIDATE"
        chmod +x "$BIN_CANDIDATE"
        # Normalize to a known path for later steps
        mv "$BIN_CANDIDATE" ./zksync_os_bin

    - name: Start Anvil (L1) and wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks
        nohup anvil --load-state zkos-l1-state.json --port ${{ inputs.l1_port }} > anvil.log 2>&1 &
        echo $! > anvil.pid
        for i in $(seq 1 60); do
          # short, bounded curl (no hang)
          reply="$(curl -fsS --connect-timeout 1 --max-time 2 -X POST "http://127.0.0.1:${{ inputs.l1_port }}" \
            -H 'content-type: application/json' \
            --data '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}')" || true
          if printf '%s' "$reply" | grep -q '"jsonrpc":"2.0"'; then
            echo "Anvil ready"
            break
          fi
          # process died?
          if ! kill -0 "$(cat anvil.pid)" 2>/dev/null; then
            echo "Anvil died during wait. Last logs:"; tail -n 200 anvil.log || true
            exit 1
          fi
          sleep 1
          if [ "$i" = "60" ]; then
            echo "Anvil not ready after $i s"; tail -n 200 anvil.log || true; exit 1
          fi
        done
        # fully detach for safety
        disown || true

    - name: Start ZKsync OS server (L2) and wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks

        echo "==> ZKsync OS binary info"
        chmod +x ./zksync_os_bin || true
        ./zksync_os_bin --version || true
        ./zksync_os_bin --help | sed -n '1,60p' || true

        echo "==> Launching ZKsync OS (fully detached)"
        export L1_RPC="http://127.0.0.1:${{ inputs.l1_port }}"
        export GENESIS="$(pwd)/genesis/genesis.json"
        export PORT="${{ inputs.l2_port }}"
        export RUST_LOG=info

        # Fully detach: new session + no inherited stdio
        setsid bash -c 'exec ./zksync_os_bin </dev/null >>l2.log 2>&1' &
        echo $! > l2.pid
        sleep 1

        if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
          echo "ZKsync OS exited immediately. Dumping l2.log:"; sed -n '1,200p' l2.log || true
          exit 1
        fi

        echo "==> Probing listeners (ss) while waiting for readiness on :${{ inputs.l2_port }}"
        for i in $(seq 1 ${{ inputs.wait_seconds }}); do
          # show listeners once per second for visibility
          (command -v ss >/dev/null && ss -ltnp || lsof -iTCP -sTCP:LISTEN -P) | sed -n '1,5p' || true

          # if process died, fail fast with logs
          if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
            echo "L2 died during wait. Last logs:"; tail -n 200 l2.log || true
            exit 1
          fi

          # 1) TCP open?
          if ! (command -v nc >/dev/null && nc -z 127.0.0.1 "${{ inputs.l2_port }}" || \
                (exec 3<>/dev/tcp/127.0.0.1/${{ inputs.l2_port }} 2>/dev/null && exec 3>&- 3<&-)); then
            sleep 1; continue
          fi

          # 2) Status server (it’s in your logs at 0.0.0.0:3071); health often comes up first
          health="$(curl -fsS --connect-timeout 1 --max-time 2 http://127.0.0.1:3071/health || true)"
          [ -n "$health" ] && echo "Status /health: $health" || echo "Status /health: (no reply yet)"

          # 3) RPC: accept any JSON-RPC envelope as alive (result OR error)
          rpc="$(curl -fsS --http1.1 --connect-timeout 1 --max-time 3 \
                  -H 'content-type: application/json' \
                  -X POST "http://127.0.0.1:${{ inputs.l2_port }}" \
                  --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}')" || true

          if printf '%s' "$rpc" | grep -q '"jsonrpc"[[:space:]]*:[[:space:]]*"2\.0"'; then
            if printf '%s' "$rpc" | grep -q '"result"'; then
              cid="$(printf "%s" "$rpc" | sed -n 's/.*"result"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)"
              [ -n "$cid" ] && echo "eth_chainId: $cid"
            else
              echo "RPC responded (error envelope), treating as ready"
            fi
            echo "L2 JSON-RPC is responding"
            break
          fi

          sleep 1
          if [ "$i" = "${{ inputs.wait_seconds }}" ]; then
            echo "L2 not ready after $i s — diagnostics:"
            echo ">>> ss -ltnp (top 50)"
            (command -v ss >/dev/null && ss -ltnp || lsof -iTCP -sTCP:LISTEN -P) | sed -n '1,50p' || true
            echo ">>> one-shot CURL -v to RPC"
            curl -v --http1.1 --connect-timeout 2 --max-time 4 -H 'content-type: application/json' \
              -X POST "http://127.0.0.1:${{ inputs.l2_port }}" \
              --data '{"jsonrpc":"2.0","id":1,"method":"web3_clientVersion","params":[]}' || true
            echo ">>> tail l2.log (last 200)"
            tail -n 200 l2.log || true
            exit 1
          fi
        done


    - name: Export RPC URLs
      if: ${{ inputs.set_env == 'true' }}
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}" >> "$GITHUB_ENV"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}" >> "$GITHUB_ENV"

    - name: Print endpoints
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}"
        echo "RESOLVED_ZKSYNC_VERSION=${{ steps.resolve.outputs.tag }}"
