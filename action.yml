name: "ZKsync Server Action (L1 + L2)"
description: "Starts anvil (L1) and zksync_os_server (L2) for L1-L2 testing"
author: "dutterbutter"
branding:
  icon: "server"
  color: "blue"

inputs:
  version:
    description: "Release tag (e.g. v0.8.2) or 'latest'"
    default: "latest"
  include_prerelease:
    description: "Allow pre-releases when version is 'latest'"
    default: "false"
  l1_port:
    description: "L1 (Anvil) RPC port"
    default: "8545"
  l2_port:
    description: "L2 (ZKsync OS) RPC port"
    default: "3050"
  linux_arch:
    description: "Linux arch (x86_64 or aarch64)"
    default: "x86_64"
  set_env:
    description: "If 'true', export ETH_RPC and ZKSYNC_RPC to GITHUB_ENV"
    default: "true"

outputs:
  l1_rpc_url:
    description: "Resolved L1 RPC URL"
    value: ${{ steps.vars.outputs.l1 }}
  l2_rpc_url:
    description: "Resolved L2 RPC URL"
    value: ${{ steps.vars.outputs.l2 }}
  resolved_version:
    description: "Resolved tag actually used (e.g. v0.8.2)"
    value: ${{ steps.resolve.outputs.tag }}

runs:
  using: "composite"
  steps:
    - id: vars
      shell: bash
      run: |
        echo "l1=http://127.0.0.1:${{ inputs.l1_port }}" >> "$GITHUB_OUTPUT"
        echo "l2=http://127.0.0.1:${{ inputs.l2_port }}" >> "$GITHUB_OUTPUT"

    # Resolve 'latest' via GitHub API (optionally including pre-releases)
    - id: resolve
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const owner = 'matter-labs';
          const repo  = 'zksync-os-server';

          const version = core.getInput('version')?.trim() || 'latest';
          const includePre = (core.getInput('include_prerelease') || 'false').toLowerCase() === 'true';

          let tag = version;

          async function latestStable() {
            const res = await github.rest.repos.getLatestRelease({ owner, repo });
            return res.data.tag_name;
          }

          async function latestIncludingPrerelease() {
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner, repo, per_page: 20,
            });
            const rel = releases.find(r => !r.draft); // first is newest
            if (!rel) throw new Error(`No releases found for ${owner}/${repo}`);
            return rel.tag_name;
          }

          try {
            if (version === 'latest') {
              tag = includePre ? await latestIncludingPrerelease() : await latestStable();
            }
            core.info(`Resolved zksync-os-server tag: ${tag}`);
            core.setOutput('tag', tag);
            core.setOutput('base', `https://github.com/${owner}/${repo}/releases/download/${tag}`);
          } catch (err) {
            core.setFailed(`Failed to resolve release tag for ${owner}/${repo}: ${err.message || err}`);
          }


    - name: Download release assets
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p .zks && cd .zks
        base="${{ steps.resolve.outputs.base }}"
        tag="${{ steps.resolve.outputs.tag }}"
        arch="${{ inputs.linux_arch }}"
        tgz="zksync-os-server-${tag}-${arch}-unknown-linux-gnu.tar.gz"

        echo "Resolved tag: $tag"
        echo "Downloading assets from: $base"
        curl -sSL -O "$base/$tgz"
        curl -sSL -O "$base/zkos-l1-state.json"
        curl -sSL -O "$base/genesis.json"
        mkdir -p genesis
        mv -f genesis.json genesis/genesis.json

        # Show archive contents for debugging
        echo "Listing archive contents:"
        tar -tzf "$tgz" | sed -n '1,200p'

        # Extract
        tar -xzf "$tgz"

        # Locate the server binary (handle both name + subfolder cases)
        BIN_CANDIDATE=""
        for name in zksync_os_bin zksync-os-server; do
          # exact match in cwd
          if [[ -f "$name" ]]; then BIN_CANDIDATE="$name"; break; fi
          # within one subdir (common packaging)
          found="$(find . -maxdepth 2 -type f -name "$name" | head -n1 || true)"
          if [[ -n "$found" ]]; then BIN_CANDIDATE="$found"; break; fi
        done

        if [[ -z "$BIN_CANDIDATE" ]]; then
          echo "ERROR: Could not find server binary in archive."
          echo "Top-level tree:"
          ls -la
          echo "Recursive tree (depth 2):"
          find . -maxdepth 2 -type f -print
          exit 1
        fi

        echo "Found server binary at: $BIN_CANDIDATE"
        chmod +x "$BIN_CANDIDATE"
        # Normalize to a known path for later steps
        mv "$BIN_CANDIDATE" ./zksync_os_bin

    - name: Start Anvil (L1) and wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks
        nohup anvil --load-state zkos-l1-state.json --port ${{ inputs.l1_port }} > anvil.log 2>&1 &
        echo $! > anvil.pid
        for i in $(seq 1 60); do
          # short, bounded curl (no hang)
          reply="$(curl -fsS --connect-timeout 1 --max-time 2 -X POST "http://127.0.0.1:${{ inputs.l1_port }}" \
            -H 'content-type: application/json' \
            --data '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}')" || true
          if printf '%s' "$reply" | grep -q '"jsonrpc":"2.0"'; then
            echo "Anvil ready"
            break
          fi
          # process died?
          if ! kill -0 "$(cat anvil.pid)" 2>/dev/null; then
            echo "Anvil died during wait. Last logs:"; tail -n 200 anvil.log || true
            exit 1
          fi
          sleep 1
          if [ "$i" = "60" ]; then
            echo "Anvil not ready after $i s"; tail -n 200 anvil.log || true; exit 1
          fi
        done
        # fully detach for safety
        disown || true

    - name: Start ZKsync OS server (L2) — no-wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks

        # Env for the server
        export L1_RPC="http://127.0.0.1:${{ inputs.l1_port }}"
        export GENESIS="$(pwd)/genesis/genesis.json"
        export PORT="${{ inputs.l2_port }}"
        export RUST_LOG=info

        echo "Launching zksync_os_bin fully detached..."
        # Start in a brand-new session, with stdin closed and logs going to l2.log
        setsid bash -c 'exec ./zksync_os_bin </dev/null >>l2.log 2>&1' &
        echo $! > l2.pid

        # Give it a moment to bind the port
        sleep 3

        # If it died instantly, fail with logs for visibility
        if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
          echo "zksync_os_bin exited during initial 3s grace. Dumping l2.log:"
          sed -n '1,200p' l2.log || true
          exit 1
        fi

        # Explicitly detach from the job table so the step can finish no matter what
        disown || true

        echo "ZKsync OS launched (pid: $(cat l2.pid)). Continuing…"

    - name: Export RPC URLs
      if: ${{ inputs.set_env == 'true' }}
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}" >> "$GITHUB_ENV"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}" >> "$GITHUB_ENV"

    - name: Print endpoints
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}"
        echo "RESOLVED_ZKSYNC_VERSION=${{ steps.resolve.outputs.tag }}"
