name: "ZKsync Server Action (L1 + L2)"
description: "Starts anvil (L1) and zksync_os_server (L2) for L1-L2 testing"
author: "dutterbutter"
branding:
  icon: "server"
  color: "blue"

inputs:
  version:
    description: "Release tag (e.g. v0.8.2) or 'latest'"
    default: "latest"
  include_prerelease:
    description: "Allow pre-releases when version is 'latest'"
    default: "false"
  l1_port:
    description: "L1 (Anvil) RPC port"
    default: "8545"
  l2_port:
    description: "L2 (ZKsync OS) RPC port"
    default: "3050"
  linux_arch:
    description: "Linux arch (x86_64 or aarch64)"
    default: "x86_64"
  wait_seconds:
    description: "Seconds to wait for L2 readiness"
    default: "300"
  set_env:
    description: "If 'true', export ETH_RPC and ZKSYNC_RPC to GITHUB_ENV"
    default: "true"

outputs:
  l1_rpc_url:
    description: "Resolved L1 RPC URL"
    value: ${{ steps.vars.outputs.l1 }}
  l2_rpc_url:
    description: "Resolved L2 RPC URL"
    value: ${{ steps.vars.outputs.l2 }}
  resolved_version:
    description: "Resolved tag actually used (e.g. v0.8.2)"
    value: ${{ steps.resolve.outputs.tag }}

runs:
  using: "composite"
  steps:
    - id: vars
      shell: bash
      run: |
        echo "l1=http://127.0.0.1:${{ inputs.l1_port }}" >> "$GITHUB_OUTPUT"
        echo "l2=http://127.0.0.1:${{ inputs.l2_port }}" >> "$GITHUB_OUTPUT"

    # Resolve 'latest' via GitHub API (optionally including pre-releases)
    - id: resolve
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const owner = 'matter-labs';
          const repo  = 'zksync-os-server';

          const version = (process.env.VERSION || 'latest').trim();
          const includePre = (process.env.INCLUDE_PRE || 'false').toLowerCase() === 'true';

          let tag = version;

          async function latestStable() {
            const res = await github.rest.repos.getLatestRelease({ owner, repo });
            return res.data.tag_name;
          }

          async function latestIncludingPrerelease() {
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner, repo, per_page: 10,
            });
            const rel = releases.find(r => !r.draft); // first is newest
            if (!rel) throw new Error(`No releases found for ${owner}/${repo}`);
            return rel.tag_name;
          }

          try {
            if (version === 'latest') {
              tag = includePre ? await latestIncludingPrerelease() : await latestStable();
            }
            core.info(`Resolved zksync-os-server tag: ${tag}`);
            core.setOutput('tag', tag);
            core.setOutput('base', `https://github.com/${owner}/${repo}/releases/download/${tag}`);
          } catch (err) {
            core.setFailed(`Failed to resolve release tag for ${owner}/${repo}: ${err.message || err}`);
          }

    - name: Download release assets
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p .zks && cd .zks
        base="${{ steps.resolve.outputs.base }}"
        tag="${{ steps.resolve.outputs.tag }}"
        arch="${{ inputs.linux_arch }}"
        tgz="zksync-os-server-${tag}-${arch}-unknown-linux-gnu.tar.gz"

        echo "Resolved tag: $tag"
        echo "Downloading assets from: $base"
        curl -sSL -O "$base/$tgz"
        curl -sSL -O "$base/zkos-l1-state.json"
        curl -sSL -O "$base/genesis.json"
        mkdir -p genesis
        mv -f genesis.json genesis/genesis.json

        # Show archive contents for debugging
        echo "Listing archive contents:"
        tar -tzf "$tgz" | sed -n '1,200p'

        # Extract
        tar -xzf "$tgz"

        # Locate the server binary (handle both name + subfolder cases)
        BIN_CANDIDATE=""
        for name in zksync_os_bin zksync-os-server; do
          # exact match in cwd
          if [[ -f "$name" ]]; then BIN_CANDIDATE="$name"; break; fi
          # within one subdir (common packaging)
          found="$(find . -maxdepth 2 -type f -name "$name" | head -n1 || true)"
          if [[ -n "$found" ]]; then BIN_CANDIDATE="$found"; break; fi
        done

        if [[ -z "$BIN_CANDIDATE" ]]; then
          echo "ERROR: Could not find server binary in archive."
          echo "Top-level tree:"
          ls -la
          echo "Recursive tree (depth 2):"
          find . -maxdepth 2 -type f -print
          exit 1
        fi

        echo "Found server binary at: $BIN_CANDIDATE"
        chmod +x "$BIN_CANDIDATE"
        # Normalize to a known path for later steps
        mv "$BIN_CANDIDATE" ./zksync_os_bin

    - name: Start Anvil (L1) and wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks
        nohup anvil --load-state zkos-l1-state.json --port ${{ inputs.l1_port }} > anvil.log 2>&1 &
        for i in {1..60}; do
          if curl -sS -X POST "http://127.0.0.1:${{ inputs.l1_port }}" \
              -H 'content-type: application/json' \
              --data '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}' | grep -q '"result"'; then
            echo "Anvil ready"
            exit 0
          fi
          sleep 1
        done
        echo "Anvil not ready"; tail -n 200 anvil.log || true; exit 1

    - name: Start ZKsync OS server (L2) and wait
      shell: bash
      run: |
        set -euo pipefail
        cd .zks

        echo "==> ZKsync OS binary info"
        chmod +x ./zksync_os_bin || true
        ./zksync_os_bin --version || true
        ./zksync_os_bin --help | sed -n '1,60p' || true

        echo "==> Launching ZKsync OS"
        export L1_RPC="http://127.0.0.1:${{ inputs.l1_port }}"
        export GENESIS="$(pwd)/genesis/genesis.json"
        export PORT="${{ inputs.l2_port }}"
        export RUST_LOG=info

        nohup ./zksync_os_bin > l2.log 2>&1 &
        echo $! > l2.pid
        sleep 1

        if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
          echo "ZKsync OS exited immediately. Dumping l2.log:"; sed -n '1,200p' l2.log || true
          exit 1
        fi

        echo "==> Waiting for L2 TCP on :${{ inputs.l2_port }}"
        for i in $(seq 1 ${{ inputs.wait_seconds }}); do
          if (exec 3<>/dev/tcp/127.0.0.1/${{ inputs.l2_port }}) 2>/dev/null; then
            exec 3>&-  # close
            break
          fi
          # died while waiting?
          if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
            echo "L2 died during TCP wait. Last logs:"; tail -n 200 l2.log || true; exit 1
          fi
          sleep 1
          if [ "$i" = "${{ inputs.wait_seconds }}" ]; then
            echo "TCP not open after $i s"; tail -n 200 l2.log || true; exit 1
          fi
        done

        echo "==> Waiting for JSON-RPC on :${{ inputs.l2_port }}"
        first_reply=""
        for i in $(seq 1 ${{ inputs.wait_seconds }}); do
          if ! kill -0 "$(cat l2.pid)" 2>/dev/null; then
            echo "L2 died during RPC wait. Last logs:"; tail -n 200 l2.log || true; exit 1
          fi

          reply="$(curl -fsS --connect-timeout 1 --max-time 2 -X POST "http://127.0.0.1:${{ inputs.l2_port }}" \
            -H 'content-type: application/json' \
            --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}')" || true

          # Record first non-empty reply for debugging
          if [ -z "${first_reply}" ] && [ -n "${reply}" ]; then
            first_reply="${reply}"
          fi

          # Consider ready if it looks like *any* JSON-RPC response (result OR error)
          if echo "${reply}" | grep -q '"jsonrpc"\s*:\s*"2\.0"'; then
            echo "L2 JSON-RPC is responding"; break
          fi

          sleep 1
          if [ "$i" = "${{ inputs.wait_seconds }}" ]; then
            echo "L2 JSON-RPC not ready after $i s"
            echo "First non-empty reply: ${first_reply}"
            tail -n 200 l2.log || true
            exit 1
          fi
        done

    - name: Export RPC URLs
      if: ${{ inputs.set_env == 'true' }}
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}" >> "$GITHUB_ENV"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}" >> "$GITHUB_ENV"

    - name: Print endpoints
      shell: bash
      run: |
        echo "ETH_RPC=${{ steps.vars.outputs.l1 }}"
        echo "ZKSYNC_RPC=${{ steps.vars.outputs.l2 }}"
        echo "RESOLVED_ZKSYNC_VERSION=${{ steps.resolve.outputs.tag }}"
